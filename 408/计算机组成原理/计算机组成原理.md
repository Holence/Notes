# 一、绪论

这门课研究冯诺依曼架构的计算机的实现方法，至于计算机体系结构该如何设计，参见《计算机体系结构》这门课。

![绪论 冯诺依曼结构](<./img/绪论 冯诺依曼结构.jpg>)

![绪论 现代结构](<./img/绪论 现代结构.jpg>)

- 输入设备：键盘、鼠标、扫描仪、摄像头、麦克风
- 输出设备：显示器、打印机
- 存储器：主存（内存）、外存（磁盘、固态硬盘）
- 运算器（ALU，Arithmetic Logic Unit）：算术运算、逻辑运算
- 控制器（CU，Control Unit）：根据指令发出控制信号

![绪论 计算机结构](<./img/绪论 计算机结构.jpg>)

高级语言到机器语言的翻译：
$$
\ce{
{.}c(源文件) ->[预处理器] {.}i(对宏命令进行预处理) ->[编译器] {.}s(汇编语言) ->[汇编器] {.}o(二进制01) ->[链接器] {.}exe(可执行文件)
}
$$
一条指令的[指令周期](#指令周期)：

![计算机的工作过程](<./img/计算机的工作过程.jpg>)

## 性能指标

时钟周期 = 1/主频

CPI (Clock Cycle Per Instruction)：执行一条指令所需要的时钟周期的个数（平均）

执行时间：执行一个程序需要的时间（加权和）

MIPS (Million Instructions Per Second)：每秒几百万条指令

MFLOPS：每秒几百万次浮点运算

GFLOPS\TFLOPS\PFLOPS

# 二、数据表示与运算

01数据是如何表示的，ALU是如何运算的

## 定点数

### 无符号数

8位，可表示0~255

#### 无符号数加法

直接加

#### 无符号数减法

A - B
0100 - 0001

减数B所有位取反再加1得C，原式转换为A+C（舍掉溢出位）

C = 1111
B + C = 10000
C = 10000 - B
A - B = A + (10000 - B) - 10000 = A + C - 10000

### 带符号数

![定点数](<./img/定点数.jpg>)

#### 原码

-127~127

第一位，0表正，1表负

0000和1000均表示0

对负数的加减不能直接加

所以设计出反码和补码

#### 反码

-127~127

正数：反码=原码

负数：反码=符号位不变，数值位取反

0000和1000均表示0

#### 补码

-128~127

正数：补码=原码

负数：补码=原码的反码+1

0000表示0，1000表示-128

$负数_{原}$、$负数_{补}$互相转换：符号位不变，从右往左的第1个的左边全部位取反

$$
-3 = 1010_{原} = 1110_{补}
$$

$负数_{补} + 负数_{原} = （最高位溢出1舍去）1000 = -128$

---

带有补码的相加，符号位参加运算

1. 于是原码带有负数的相加，应该把负数转换为补码，再进行相加（舍掉溢出位），最后再转回原码。

$$
3 - 5 = 0011_{原} - 0101_{原} = 0011_{原} + 1101_{原} = 0011_{补} + 1011_{补} \\ = 1110_{补} = 1010_{原} = -2
$$

2. $正数_{补} + 负数_{补} = （最高位溢出1舍去）0000$ 所以减去一个正数补码，等于加上一个负数补码（$正数_{补}$、$负数_{补}$互相转换：包括符号位全部位取反，再加1）

### 移位

算数移位（有符号数）

![算数移位](<./img/算数移位.jpg>)

> 无符号数的算术移位等同于逻辑移位

逻辑移位：左右补0

循环移位：循环补

### 补码加（减）法器

一位全加器FA：

![一位全加器](<./img/一位全加器.jpg>)

加法器：多个一位全加器FA串联

![加法运算器](<./img/加法运算器.jpg>)

加减器：

用一个多路选择器，在减法的时候把它的补码全部位取反，再在加法中设初始进位为1

这样就转换为做加法了

![加减运算器](<./img/加减运算器.jpg>)

#### 标志位

程序状态字 PSW (Program Status Word)

- OF（Overflow Flag）（有符号计算）溢出标志：$符号位处相加的进位 \oplus 数值位最高位处相加的进位$，为0表示不溢出，为1表示溢出（⊕异或）

  > 同正相加符号位不进位，数值最高位不进位，0⊕0=0，不溢出
  >
  > 同负相加符号位进位，数值最高位进位（不溢出的数值相加，在补码形式中最高位会进位），1⊕1=0，不溢出
  >
  > 正负相加，不可能溢出

  <u>在乘除的运算中，为了不丢弃中间的溢出结果，多位符号位可以保留溢出的符号位以及数值位</u>

  <u>如双符号位，00表示正，11表示负：相加后01表示正溢出，10表示负溢出</u>

- SF（Sign Flag）（有符号计算）符号标志：就是符号位最后的值，为0表示结果为正，为1表示结果为负

- ZF（Zero Flag）（有符号\无符号计算）零标志：为1则表示结果（包括符号位）全为0

- CF（Carry Flag）（无符号计算）加法进位or减法借位标志：$Sub \oplus 最高位处相加的进位$，为0表示不进位or借位，为1表示进位or借位（⊕异或）

  > 做加法，Sub为0，$CF = 最高位处相加的进位$。两个无符号数相加，若最高位无进位，则表示无进位。
  >
  > 做减法，Sub为1，$CF = \overline{最高位处相加的进位}$。两个无符号数相减，减数全部位取反再加一后，转换为相加。试一试3-5和5-3，发现这时最高位进位了才说明结果为正数（无借位），而最高位无进位才说明结果为负数（有借位）。
  >
  > 详细证明：
  >
  > > 我也困惑了好久，但是真正理解了简直豁然开朗！
  > >
  > > 首先明确一点，CF进位标志只有在无符号整数运算时才有意义，有符号运算的溢出是用另一个标志OF判断的。
  > >
  > > 无符号减法需要转换一下思路。我们来考察 a-b这个式子：
  > >
  > > 1. 加法器不管你是有符号还是无符号，统一按照补码操作，将减数取反加一（参考讲负数从原码转为补码）；
  > > 2. 减数取反加一后，原算式就能改为加法，即 a + b'；
  > > 3. 而学过整数的补码定义的小伙伴们都知道，参照负数的补码定义，上式的 b' 的数值等于 $2^n-b$；
  > > 4. 原式化作 $a-b+2^n$；
  > > 5. 此时再考察运算结果，不难发现，如果进位输出C_out为1，则表示该结果大于等于 $2^n$，即 $a-b+2^n >= 2^n$，则 $a-b >= 0$，计算时无需借位，借位标志 CF 为0。反之，当进位输出为0时，计算结果小于 $2^n$，$a-b < 0$，计算时需要借位，借位标志 CF 为1。
  > >
  > > 综上所述，无符号减法时的 CF 为 C_out 取反。
  > >
  > > 作者：空想之野
  > > 链接：https://www.zhihu.com/question/53732747/answer/2718887873

### ALU

由加法器、移位器、逻辑运算器构成

有了ALU才能进行乘法和除法

### 乘法

#### 原码乘法

🤮

#### 补码乘法

🤮

### 除法

🤮

### 定点数类型转换

用补码存储数

```c
short <=> unsigned short //字长不变，数值不变，解释变，真值变
int <=> unsigned int //字长不变，数值不变，解释变，真值变
short => int  //字长变长，数据不变，若为正数则左边补0，若为负数则左边补1，真值不变
int => short //字长变短，数据不变，高位截断，真值变
```

## 浮点数

一位数符S表正负1 多位阶码E表2的几次方（补码） 多位尾数M表底数（正数原码） = $S * 2^E * M$

为了最大化可表示的范围，要先对数进行规格化：调整尾数和阶数，使尾数变为0.???的形式

### IEEE 754

在原设计上有所改变：

- 阶码，要把补码变移码，再-1偏移
- 尾数，并化为1.???的形式

### 移码

目的是让补码变得能直接看出真值的大小（因为在浮点数的加减法中，需要先判断阶数的大小）

操作：补码的符号位0变1，1变0

### IEEE中的阶码

而IEEE中的阶码，在移码操作后还需要再做-1的操作（这样让全1为无穷，全0为0）

float类型8位的$IEEE阶码=阶码真值+127$

| 阶码真值 | 阶码原码  | 阶码补码   | 阶码移码  | IEEE的阶码 | 阶码在IEEE中的用途                                           |
| -------- | --------- | ---------- | --------- | ---------- | ------------------------------------------------------------ |
| -128     | NA        | 1000 0000  | 0000 0000 | 1111 1111  | 阶码全1<br />若尾数为0，则表示$\pm \infty$<br/>若尾数不为0，则表示$NaN$ |
| -127     | 1111 1111 | 1000 0001  | 0000 0001 | 0000 0000  | 阶码全0<br />若尾数为0，则表示$\pm 0$<br />若尾数不为0，则表示未规格化的数：$\pm (0.???)_2*2^{-126}$ |
| -126     | 1111 1110 | 1000 0010  | 0000 0010 | 0000 0001  | 阶码为1，阶码真值为-126<br/>当尾数全0时，取到最小值$\pm (1.0)_2*2^{-126}$ |
| -1       | 1000 0001 | 11111 1111 | 0111 1111 | 0111 1110  | $2^{-1}$                                                     |
| 0        | 0000 0000 | 0000 0000  | 1000 0000 | 0111 1111  | $2^0$                                                        |
| 127      | 0111 1111 | 0111 1111  | 1111 1111 | 1111 1110  | 阶码为254，阶码真值为127<br/>当尾数全1时，取到最大值$\pm (1.111\dots)_2*2^{127}$ |

三种浮点类型

| 浮点类型                 | 数符位数 | 阶码位数 | 尾数位数 | 总位数 | 阶码偏置         |
| ------------------------ | -------- | -------- | -------- | ------ | ---------------- |
| float、短浮点数、单精度  | 1        | 8        | 自己算   | 32     | $2^7-1=127$      |
| double、长浮点数、双精度 | 1        | 11       | 自己算   | 64     | $2^{10}-1=1023$  |
| long double、临时浮点数  | 1        | 15       | 自己算   | 80     | $2^{14}-1=16383$ |

例：

求-0.75的IEEE 754单精度浮点数
$$
位数：1+8+23=32\\
-0.75 = -1 * (0.11)_2 = -1 * 2^{-1} * (1.1)_2\\
=  -1 * 2^{(1000\ 0001)_原} * (1.1)_原\\
=  -1 * 2^{(1111\ 1111)_补} * (1.1)_原\\
=  -1 * 2^{(0111\ 1110)_{IEEE阶码}} * (1后面跟22个0)_{IEEE尾数}

\\所以为：1\ 01111110\ 1后面跟22个0
$$
求IEEE 754单精度浮点数`C0 A0 00 00 H`的真值
$$
C0\ A0\ 00\ 00_H = 1100\ 0000\ 1010\ 0000\ 0000\ 0000\ 0000\ 0000_2\\
位数：1+8+23=32\\
数符：-1\\
阶码：1000\ 0001=0000\ 0010_{补}=0000\ 0010_{原}=2_H\\
尾数：1.01_原=1+0.25=1.25\\
所以为：-1*2^{2}*1.25=-5.0
$$

### 浮点数加减法

1. 小阶向着大阶对齐（使更小的数成为更大的数的尾数）
2. 尾数求和
3. 规格化
4. 舍入
5. 溢出？？？如果尾数舍入和加减产生了溢出，尝试做规格化改变阶数，若阶数又溢出了，那就真的溢出了。下溢是0，上溢是抛出异常中断。

### 浮点数类型转换

![浮点数类型转换](<./img/浮点数类型转换.jpg>)

# 三、存储系统

主存、Cache、辅存的内部是怎样的，以及Cache-主存层、主存-辅存层是啥。

## 结构

电脑：

- 主机
  - CPU
    - 寄存器Register
    - 高速缓冲存储器Cache
  - 内存（主存）
- 辅存、外存（磁带、光盘、硬盘）

越接近内部，速度越快、容量越小、造价越高

![存储结构](<./img/存储结构.jpg>)

## 属性与分类

按照属性分类：

- 存储介质

  - 半导体、磁表面、光

- 存取方式（SAM和DAM都属于串行访问存储器）

  - SAM (Sequential Access Memory) 顺序存取存储器：需要按照物理位置寻址，如磁带

  - RAM (Random Access Memory) 随机存取存储器：读取任意一个地址的存储单元需要的时间都相同，如内存

    > RAM的信息读出后是否要破坏原信息：
    >
    > - 破坏性读出：DRAM (Dynamic Random Access Memory) 主存
    > - 非破坏性读出：SRAM (Static Random Access Memory) 高速缓冲存储器Cache

  - DAM (Direct Access Memory) 直接存取存储器：磁头先按顺序存取寻道，再随机存取读取，如磁盘（软盘、硬盘）、光盘

  - 相联存储器：按内容寻址（快表就用的这个）

- 信息的可更改性

  - RWM (Read Write Memory) 读写存储器
  - ROM (Read Only Memory) 只读存储器

- 断电后信息是否消失

  - 易失性存储器：RAM
  - 非易失性存储器：ROM、DAM、SAM

## 数据存储与排列

**字**

字就是存储单元，每次存取操作的就是一个存储单元，其长度应该为字节的整数倍，比如4个字节的存储单元。

❓！！！以下内容真实性不确定！！！烦死了，网上找不到全面的解答

主存的内禀属性：存储单元的宽度、按字节编址（现代很少会按字编址了）

CPU是肯定可以按字寻址的，因为字就是主存的存储单元。传入主存地址线的是字长整数倍的完整地址（如0000、0100、1000、1100。如果从虚拟地址的视角看，舍弃掉末尾的0，字地址也就成连续的了），传出的就是一整个字。

CPU控制器指令集、总线的设计决定了是否能进行按字节寻址。此时传入主存地址线的依旧是将最后几位置为0的地址，取出的依旧是一整个字，回到CPU中再根据原先地址的最后几位对这个字进行移位操作，只保留选定字节的数据。

> https://stackoverflow.com/questions/48129466/why-do-we-use-byte-addressing-instead-of-word-addressing
>
> https://stackoverflow.com/questions/2724449/difference-between-word-addressable-and-byte-addressable
>
> https://cs.stackexchange.com/questions/113542/byte-addressable-vs-word-addressable

**边界对齐**

若一段数据没有一个字那么长，就应该在后面填充空数据。如果继续在其后存其他的数据，其他的数据就会跨行（跨字），当要访问跨行的数据时得进行多次访存，时间效率低。这是空间换时间的思想。

**大端、小端**

多字节的数据的连续存储方式

一个4字节的int：`01 23 45 67 H`

- 高位/最高有效位 MSB Most Significant Bit：01
- 低位/最低有效位 LSB Least Significant Bit：67

若存储单元的长度是1个字节

- 大端方式：高位在前，低位在后（`01 23 45 67`）
- 小端方式：低位在前，高位在后（`67 45 23 01`）

大端和人的读写顺序一致，但不利于机器处理。机器按顺序读取，应该先读低位的数据，因为算数都是从低位开始做的。

## 性能指标

- 存储容量=存储字数*字长
- 单位成本=钱/容量
- 存取周期=存取时间+恢复时间
- 数据传输率（主存带宽）=数据宽度/存取周期

## RAM

![RAM](<./img/RAM.jpg>)

### DRAM

Dynamic Random Access Memory

![DRAM 存储单元](<./img/DRAM 存储单元.jpg>)

一个电容：01

一个MOS：读写开关

读出即电容放电，是破坏性的，因此需要重写（再生），所以存取速度慢

电容在2ms后会流失，所以需要不停地给电容充电（刷新）

![主存](<./img/主存.jpg>)

MAR -> 地址线 -> 译码器 -> 读出\写入 -> 数据线 -> MDR

片选线：8G的内存条是由8个1G的存储器并起来的，需要用片选线指定选哪个

#### 刷新

二维中的刷新，每次刷新一整行。是靠主存内部的刷新电路完成的，不需要依靠外部控制。

如16MB，共16384个存储单元，分为128*128的阵列，每次刷新一行的128个，共需要刷新128次。

在2ms的刷新周期（超出刷新周期信息就丢失了）内，需要对128行进行刷新

每次刷新是读出一整行的128个存储单元，再重新写入，占时一个存取周期

集中刷新（笨）：在128次刷新集中在2ms的最后，会产生“死时间”

分散刷新（笨）：每次读取操作后，都进行一次刷新（可能一个刷新周期内，进行完128次后就不再继续了）

异步刷新（好）：每间隔2ms/128的时间就进行一行的刷新

### SRAM

Static Random Access Memory

![SRAM 存储单元](<./img/SRAM 存储单元.jpg>)

双稳态触发器

6个MOS管，功耗大（发热大）、占地大、造价贵、集成度低

只要不断电就不会流失，运行速度快

### 多维排布

由于DRAM的存储单元更多

256个存储单元，按一维排，就得有256根选通线，对应需要一个译码器

按二维排，弄成16*16的阵列，就只用32根选通线，对应需要两个译码器（行列）

甚至可以三维……

### DRAM\SRAM对比

![SRAM vs DRAM](<./img/SRAM vs DRAM.jpg>)

## 主存 Main Memory

用DRAM制作

### 地址线复用技术

由于DRAM的地址位数更长

$1GB = 2^{30}B$

30根地址线，30个针脚

可以考虑行列地址分前后两次输入，减少为15个针脚，15个地址线

### 提高速度的方法

因为存取周期中包含恢复时间，所以希望通过一些技术规避掉恢复时间的影响

#### 单体多字存储器

在一个主存中，扩宽数据线，读一次就“并行地”取出了m个存储单元，再分时通过总线送给CPU

#### 多体并行存储器

m个主存，用一套地址编码于是会多出$log_2(m)$位的体号。

体号在前，称为**高位交叉编址**（顺序方式；体号在后，称为**低位交叉编址**（交叉方式）。

由于数据都是连续存储的，所以把体号放在低位，也就是图中右边的方式，可以以流水线的方式读取，构成了双通道。而左边的高位交叉只是在单纯的扩容。

那就管右边的叫“**多体低位交叉存储器**”

若存取周期为T，存取时间为r，恢复时间为3r，连续读取n个存储单位，则在最理想的情况时，需要$(n-1)*r+T$的时间（最后一个得算全恢复时间）

而最理想的情况是，存储体的个数m，需要大于等于$T/r$。当m=T/r时，效率最高，各个存储体将没有任何空闲时间。

![DRAM 多体并行存储器](<./img/DRAM 多体并行存储器.jpg>)

> 所以装电脑的时候，买两条相同容量（容量相同才能有效地并行编址，不然多出来的部分就又成单体了）、相同主频（存储周期若是不同，高频的会被降到低频）的8GB内存，插到相同规格的接口上，比只买一条16GB的效果好。

### 高性能的存储器

SDRAM (Synchronous DRAM)，时钟同步，速度更快

DDR SDRAM (Double Data Rate SDRAM)，更快更快

### 扩充容量的方法

#### 位扩展

8个$64 \times 1$位的，地址端、片选端、读写控制端都并接，数据端依次接到数据线上，形成$64 \times 8$位

#### 字扩展

4个$16 \times 8$位的，4条地址线并接各自的地址端上，各自的读写控制端、数据端并接，因为不能同时读写，所以再用CPU的地址线控制片选端，形成$64 \times 8$位的

- 线选法（笨）：CPU的1条地址线控制1个，所以为了控制4个片选端需要4条地址线。地址空间不连续（只有0001, 0010, 0100, 1000四种有效），但电路简单。
- 译码片选法（好）：通过译码器，2位的地址线可以控制4个片选端。地址空间连续（00, 01, 10, 11均有效），但电路复杂。

#### 字位同时扩展

两种方法结合

$1K\times1位$的可以用32*32的单元阵列构成，10根地址线，1根数据线，总容量$1Kb$

32个并一起位扩展，构成$1K\times32位$的，10根地址线，32根数据线，总容量$1K*32b=4KB$

1024个$1K\times32位$的串一起，构成$1M\times32位$的，20根地址线，32根数据线，总容量$1M*32b=4MB$

1024个$1M\times32位$的串一起，构成$1G\times32位$的，30根地址线，32根数据线，总容量$1G*32b=4GB$

![DRAM 字位同时扩展](<./img/DRAM 字位同时扩展.jpg>)

## 高速缓冲存储器 Cache

![Cache-主存](<./img/Cache-主存.jpg>)

用SRAM作Cache，弥补DRAM主存存取速度慢的缺陷，但由于SRAM体积大，集成度低，所以放到CPU内的Cache的容量很小

### 工作顺序

①CPU会先去Cache寻找下一个地址的数据，若Cache中没有的话再去主存中找

②或者同时开始去两者中找

若Cache中没有，则还需复制到Cache中（以备下次用）

### 性能指标

命中率$H$：在Cache中能够找到的比率

Cache-主存的平均访问时间(访问Cache：$t_c$，访问主存：$t_m$)：

①=$H*t_c+(1-H)*(t_c+t_m)$ 

②=$H*t_c+(1-H)*t_m$ 

### 放哪些数据到Cache中

选择把具有**局部性**的数据放到Cache中：

- 空间局部性：顺序执行的代码、连续存储的数组（由于Cache的这种设计原理，编写遍历数组的程序时，按行遍历的速度比按列遍历快）
- 时间局部性：循环结构的代码

### 如何界定周围

简单粗暴，分块，Cache和主存的块的宽度都是相同的，互相传送数据是一块一块传。

Cache需要记录存储块所对应的主存的块号，访问数据还需要块内地址进一步查。

![Cache-主存 分块](<./img/Cache-主存 分块.jpg>)

### 块的映射

![Cache-主存 映射](<./img/Cache-主存 映射.jpg>)

1. 全相联映射

存的时候见缝插针，若没空位则新的会选择性地覆盖一个旧的，并记录主存中的块号作为标记

读的时候对标记一个一个匹配，若有匹配的（且有效位为1），则在Cache中找到了，继续用块内地址查内容，否则去主存中找

<u>空间利用率最高（最大可能存满），但读取效率最低</u>

![Cache-主存 映射1](<./img/Cache-主存 映射1.jpg>)

2. 直接映射

存的时候主存块号除以Cache块数n取余，余数相同的放在同一个位置，若没空位则新的会覆盖旧的

取余的操作相当于直接取主存块号的末$log_2n$位，因此Cache中只用记录主存块号的前半部分，作为标记（要用比较器来区分映射到同位置的）

读的时候根据主存块号的末$log_2n$位直接对应Cache中的行，若标记匹配（且有效位为1），则在Cache中找到了，继续用块内地址查内容，否则去主存中找

<u>空间利用率最低（很可能存不满），但读取效率最高（只用作一次匹配判断）</u>

![Cache-主存 映射2](<./img/Cache-主存 映射2.jpg>)

3. 组相联映射

综合前两者的优点，Cache内8块按2路分组，共4组。存的时候组内见缝插针，若没空位则新的会选择性地覆盖一个旧的

取主存块号末$log_2(组数)=2$位，因此Cache中只用记录主存块号的前半部分，作为标记（要用比较器来区分映射到同组的，这里也就是2个比较器）

读的时候根据主存块号的末$log_2(组数)=2$位直接对应Cache中的组，在组内的两个中，若与组内的某一个标记匹配（且有效位为1），则在Cache中找到了，继续用块内地址查内容，否则去主存中找

<u>空间利用率和读取效率介于前两者之间，综合效果好</u>

![Cache-主存 映射3](<./img/Cache-主存 映射3.jpg>)

### 块的替换算法

在全相联映射和组相联映射中都会有选择性地替换旧的

- RAND 随机：随机替换

  > 没考虑局部性，命中率低

- FIFO 先进先出：队列

  > 没考虑局部性，命中率低
  >
  > **抖动现象**：Cache只有4块，以{1, 2, 3, 4, 5, 1, 2, 3, 4, 5}的顺序访问，将会产生频繁的换入换出现象

- LFU (Least Frequently Used) 最不经常使用：对每个Cache块设定一个计数器，记录访问过的次数。新进入的计数器设为0，之后每命中一次++，需要替换时选择计数器最小的那个（若多于一个，则选行号最小的或FIFO策略）

  > 没有很好地考虑局部性
  >
  > 计数器没有上限，可能在一个时间段连续使用的程序，之后就不再使用了，而却因为计数器数值最大依旧留在Cache中

- LRU (Least Recently Used) 最近最少使用：对每个Cache块设定一个计数器，记录最近一次未被访问过的次数。

  - 若命中，则其他计数器数值小于命中的计数器的++，命中的计数器清零
  - 若未命中，且有空位，则空位的计数器置0，其余的计数器++
  - 若未命中，且没空位，则覆盖掉计数器数值最大的，并把计数器置0，其余的计数器++

  > Cache的块数为n（组相联映射是一组内的块数），则只需要$log_2n$位的计数器，且当装满的时候计数器的值将排满$0 \sim 2^n-1$
  >
  > 考虑了局部性（近期访问次数最少的，将被最先淘汰），运行效果最好，Cache命中率最高
  >
  > 若集中访问的数量大于了Cache的块数，依旧会发生抖动现象

### Cache写操作的策略

因为Cache和主存中都有数据，或只有主存有数据，为了保证双方的内容一致

1. 全写（直写）法+非写分配法：（Cache和主存**全**都要**写**）带一个写缓冲
   - 当Cache中命中时（全写法），写入Cache和一个异步的写缓冲，这个写缓冲会以FIFO的顺序自动往主存中写
   - 当Cache未命中时（非写分配法），直接写入主存
2. 回写法+写分配法：（**回**到主存的时候再**写**）Cache中每位带脏位
   - 当Cache中命中时（回写法），Cache中每位设计一个脏位（修改位），写入Cache，将脏位置1，当这个块要被替换的时候，再看脏位是否要求写回主存
   - 当Cache未命中时（写分配法），先让Cache读入该块，再在Cache中写并将脏位置1

现代CPU用多级Cache，越靠近内层速度越快，容量越小。

![多级Cache](<./img/多级Cache.jpg>)

## Cache-主存层的思想

Cache-内存的分块思想，构造出了虚拟的块地址（块号）和虚拟的块内地址，所以分两步寻址。

主存有64KB，设定一块为1KB（1024个1B的存储单元），则总共64块，块号有6位，块内地址有10位。

Cache有8KB，则总共8块，那么Cache的一块中存了什么？

- 全相联映射：1位有效位 + 6位标记（完整的块号） + 10位块数据
- 直接映射：1位有效位 + 3位标记（被截短的块号，3位行号隐含了） + 10位块数据
- 组相联映射（设为2路，则为4组）：1位有效位 + 4位标记（被截短的块号，2位组号隐含了） + 10位块数据

若用的是回写法，还要再加1位脏位

CPU的MAR发出 6位完整块号 + 10位块内地址 的地址，问Cache要数据，Cache拿 6位完整块号 根据三种映射方式看是否能命中，若命中则再用 10位的块内地址 访问 $2^{10}*1B$ 的块数据，取回1B的数据到MDR中。若没命中，则CPU用 16位的完整地址 问主存要数据，取回1B的数据到MDR中。

## ROM

![ROM](<./img/ROM.jpg>)

ROM也是可以支持随机存取的

虽然ROM名字上是只读，但很多ROM是可以写的

写的速度比读的速度慢，因为写之前需要先擦除

BIOS (Basic Input Output System)就是装有一些基础程序的ROM

## 外存

### 磁盘 HDD

Hard Driver Disk

不支持随机存取

![磁盘](<./img/磁盘.jpg>)

扇区（一个磁道内的一段弧）：磁盘读写的最小单位

扇区上存储数据、扇区号（转来转去分不清谁是第0个谁是第1个）、校验信息等

#### 地址

`驱动器号 柱面（磁道）号 盘面号 扇区号`

> 为什么柱面号在盘面号之前？而不是`盘面号 柱面（磁道）号 扇区号`？
>
> 因为磁盘有多层盘面，“磁头不动，改变读取的盘面”和“读取同一个盘面。改变磁头位置”相比，肯定是前者耗时少。
>
> 出于连续存储的考虑，更低位的地址是更经常会变化的，所以应该选耗时更短的，也就是盘面号，更高位的选柱面号。

#### 性能指标

##### 容量

非格式化容量：磁化单元总量

格式化容量：按某种文件记录格式存储的信息总量

格式化容量<非格式化容量

##### 密度

- 道密度：沿半径方向，1cm内的磁道数量
- 位密度：沿磁道方向，1cm内的bit数
- 面密度：道密度*位密度

注：早期的磁盘在不同半径的磁道上，越靠内存储的越密集，越靠外越稀疏

![早期磁盘](<./img/早期磁盘.webp>)

后来为了利用这些被浪费的空间，在靠外的地方会加大存储频率

![现代磁盘](<./img/现代磁盘.jpg>)

##### 平均存取时间

寻道时间（磁头转到磁道的时间） + 延迟时间（扇区转到磁头下的时间） + 传输时间（转几分之一圈）

通过软件能加速的，只有寻道时间：对多个进程的寻道操作，如何规划出寻道时间最短的序列？

- 先来先服务
- 最短寻道时间：距离当前位置最近的
- 优先级？
- 扫描算法：和电梯一样，往一个方向走到最远的请求点，再反向走到最远的请求点
- 循环扫描算法：只有朝正方向方向移动时才访问，负方向直接回到0的位置

---

由于读完一个磁道后需要一定的处理时间，扇区的编号也能减少延迟时间：

- 交替编号：同一个磁道内，扇区号以`0, 4, 1, 5, 2, 6, 3, 7`的交错方式编址。于是对于访问连续的地址，就有了一段休息时间（不用空转一圈了）

  > 读完0-7需要转两圈

- 错位命名：后一层的盘面的扇区号要滞后一位，这样从7读到8的时候也有了一段休息时间

  ![磁盘 错位命名](<./img/磁盘 错位命名.jpg>)

##### 数据传输率（速率）

r (转/s) * 一条磁道的容量N (bit) = r*N (bit/s)

#### 磁盘阵列

RAID (Redundant Array of Independent Disks)

RAID0：类似多体低位交叉存储的思想，提升了存取速度，无法恢复

RAID1：单纯的备份，不能提升存取速度，没有纠错码（所以只能靠堆备份的数量来提升恢复的可能性）

RAID2+：交叉存储，可纠错

### 固态硬盘 SSD

Solid-State Drive

属于ROM

支持随机存取

以“页”为单位存取

![固态硬盘](<./img/固态硬盘.jpg>)

![固态硬盘小结](<./img/固态硬盘小结.jpg>)

## 主存-辅存层

- 虚拟存储器
- 页式虚拟存储器
- 段式虚拟存储器
- 段页式虚拟存储器


见《操作系统》的“内存分配与回收 - 非连续分配”

# 四、指令系统

机器指令由哪些部分构成，各部分是干啥的，汇编语言与机器语言的对应关系。

指令：操作码 + （寻址特征） + 地址码

## 指令格式

按照地址的数量分类

![指令-地址码数目](<./img/指令-地址码数目.jpg>)

按指令长度是否可变分类

- 定长指令字结构
- 变长指令字结构

按操作码长度是否可变分类

- 定长操作码：n位操作码支持$2^n$种操作码

  > 控制器的译码电路设计简单，但灵活性低

- 可变长操作码：

  ![可变长操作码](<./img/可变长操作码.jpg>)

按操作类型分类

- 数据传送：CPU、主存的数据传输
- 算数逻辑：算数和逻辑
- 移位
- 转移：改变程序的执行顺序
  - 无条件转移：JMP
  - 条件转移：JZ、JE...
  - 调用、返回：CALL、RET
  - 陷阱与陷阱指令
- 输入输出：CPU寄存器与I/O设备寄存器的数据传输
- 其他：等待、停机、空指令、开中断、关中断……

## 指令寻址

- 顺序寻址：PC+=1个指令字长（不知道变长指令字结构怎么确定指令字长）
- JMP

## 数据寻址

指令中写的地址不一定直接就是数据的真实地址

这里把指令中给出的地址记为A (Address)，真实的地址记为**有效地址**EA (Effective Address)

那么指令中就需要一个**寻址特征**的标志，来告诉控制器该怎么操控才能获得有效的地址。

![数据寻址](<./img/数据寻址.jpg>)

### 直接寻址

$EA=A$

1次访存：取EA中的数据

> 优点：简单，一次就完事
>
> 缺点：A的位数受指令字长限制，寻址范围较小。地址固定不变

### 间接寻址

$EA=(A)$ 真实的地址是A地址中的数据

2次访存：取A中的地址EA，取EA中的数据

还可以多次间接寻址：

(A)=A1

(A1)=EA

> 优点：可扩大寻址范围。便于实现子程序返回的程序
>
> 缺点：需要多次访存

### 寄存器寻址

与直接寻址类似，不过A是通用寄存器的地址$R_i$

$EA=R_i$ 

0次访存：在通用寄存器中取数据

> 优点：不用访问内存，速度快，指令字短，支持矩阵运算
>
> 缺点：寄存器容量小，寻址空间有限

### 寄存器间接寻址

与直接寻址类似，不过A是通用寄存器的地址$R_i$

真实的地址是通用寄存器$R_i$地址中的数据

$EA=(R_i)$ 

1次访存：在通用寄存器的$R_i$中取出真实地址EA，在主存中取EA中的数据

> 优点：比间接寻址速度更快

### 隐含寻址

一地址指令的操作，比如ADD，就隐含表达了另一个数据在ACC里

0次访存

> 优点：不需要访存。缩短了指令字长
>
> 缺点：需增加存储隐含数据的硬件

### 立即寻址

A的位置放的不是地址，而是操作数（被称为立即数）

寻址特征是一个#井号（汇编里的`123`就是立即数）

0次访存

> 优点：不需要访存
>
> 缺点：A的位数限制了立即数的范围

### 基址寻址（偏移寻址）

基于基址进行固定的偏移（多道程序）

基址寄存器 BAR (Base Address Register)，国内简写为BR

> 操作系统中的“重定位寄存器”
>
> 程序运行前，BR被设置为程序的起始地址，存在操作系统的PCB中

$EA=(BR)_{基址}+A_{偏移量}$

1次访存：BR内的地址和A中的偏移量在ALU中相加得到EA，取EA中的数据

若CPU中没有BR，则可以将基址存在通用寄存器中，在指令中设置几位表示$R_i$

EA=($R_i$)+A

注：基址寄存器是面向操作系统的，内容是由操作系统或管理程序确定的

### 变址寻址（偏移寻址）

基于基址进行可变的偏移（循环程序）

变址寄存器 IX (Index Register)

与基址寻址类似，但基址是A，而偏移量是(IX)

```c
for (int i=0; i<10; i++) {
	sum += a[i];
}
```

A是a\[\]的基址

IX存的是i

$EA=A_{基址}+(IX)_{偏移量}$

1次访存：A内的地址和IX中的偏移量在ALU中相加得到EA，取EA中的数据

注：变址寄存器是面向用户的，内容可由用户改变

变址寻址和基址寻址结合，$EA=\{(BR)+A\}_{基址}+(IX)_{偏移量}$

### 相对寻址（偏移寻址）

基于PC进行偏移（转移指令）

相对于PC的地址（是+1个指令字长后的地址），向前向后偏移

for循环中的`JMP A`，就是在loop的最后一行，（条件）转移到loop的第一行，偏移量就是负的loop内的行数

$EA=PC_{基址}+A_{偏移量}$

1次访存：PC内的地址和A中的偏移量在ALU中相加得到EA，取EA中的数据

### 堆栈寻址

堆栈指针 SP (Stack Pointer)，可以用通用寄存器的一行来存储。

- POP出栈：$EA=(SP)$，然后才SP++或--
- PUSH入栈：SP--或++，然后才$EA=(SP)$

是一块按LIFO（后进先出）原则管理的存储区，用通用寄存器实现的叫硬堆栈，用主存实现的叫软堆栈。

硬堆栈访存0次，软堆栈访存1次

## 汇编语言

一条C语言对应好多条汇编语言，一条汇编语言对应一条机器指令

主要记Intel的

![汇编语言 AT&T - Intel](<./img/汇编语言 AT&T - Intel.jpg>)

### 操作数

![汇编语言 数据](<./img/汇编语言 数据.jpg>)

### 算数、逻辑、移位

![汇编语言 算数运算](<./img/汇编语言 算数运算.jpg>)

![汇编语言 逻辑运算](<./img/汇编语言 逻辑运算.jpg>)

### 转移

#### 无条件转移

JMP

![汇编语言 jmp](<./img/汇编语言 jmp.jpg>)

#### 条件转移

cmp+jx

![汇编语言 cmp jx](<./img/汇编语言 cmp jx.jpg>)

#### 循环

朴素循环

![汇编语言 循环](<./img/汇编语言 循环.jpg>)

loop循环

![汇编语言 循环 loop](<./img/汇编语言 循环 loop.jpg>)

#### 函数调用

call、ret负责调度PC（IP）

![汇编语言 call ret](<./img/汇编语言 call ret.jpg>)

如何访问栈帧内部的字节，进行子函数空间的临时变量的存取

![汇编语言 访问栈帧](<./img/汇编语言 访问栈帧.jpg>)

栈帧的栈顶指针esp、栈底指针ebp在调用子函数时是如何切换的？

![汇编语言 栈帧切换](<./img/汇编语言 栈帧切换.jpg>)

本函数的局部变量放在当前函数栈帧的栈底，传入子函数的参数可以放在当前函数栈帧的栈顶

![汇编语言 栈帧总结](<./img/汇编语言 栈帧总结.jpg>)

## CISC/RISC

CISC (Complex Instruction Set Computer) 复杂指令系统计算机

RISC (Reduced Instruction Set Computer) 精简指令系统计算机

![CISC RISC](<./img/CISC RISC.jpg>)

# 五、中央处理器

CPU的功能：

1. 指令控制：取指令、分析指令、执行指令，程序的顺序控制
2. 操作控制：一个指令的操作码需要多个微操作来实现，CPU要把控制信号发给相应的部件
3. 时间控制：对各种操作加以时间上的控制
4. 数据加工：ALU的算数逻辑运算
5. 中断处理：要对程序以外的（不可预测的）异常情况、特殊请求进行响应（如鼠标点击）

CPU里有ALU、控制器、寄存器、内部总线。

第二章讲了ALU，第三章讲了SRAM（也是寄存器的实现），总线将在第六章讲。

这一章研究CU控制器，这是CPU的核心。

CU控制器根据目前所处的机器周期、指令中的操作码、时钟的节拍信号、机器状态条件（ALU的PSW、I/O设备或主存的状态），来决定发出哪些控制信号，以让数据在各个部件间流动，从而完成指令。

> 删掉
>
> 控制器需要做的：
>
> 1. 取指令：
>    - 取指令
>    - 形成指令地址（PC+=1个指令字长）
>
> 2. 分析指令：
>    - 对操作码进行译码
>    - 产生操作数的真实地址EA
> 3. 执行指令：
>    - 形成控制信号的控制序列，控制ALU、主存、I/O设备交换、运算
> 4. 中断处理：
>    - 管理总线、输入输出
>    - 处理异常情况、特殊请求
>

![CPU](<./img/CPU.jpg>)

## 指令周期

指令是我们希望机器实现的任务，但一句简单的`ADD eax, [114514]`，就得分为几个步骤才能实现，完成整个指令需要的时间叫指令周期，完成一个小步骤的叫机器周期。

![指令周期 机器周期](<./img/指令周期 机器周期.jpg>)

一个指令周期需要三到四个机器周期。

一个机器周期又需要好多个微操作来实现，每个微操作占用一个时钟周期（1/主频）。

![指令周期](<./img/指令周期.jpg>)

### 四个机器周期

四个机器周期里都分别需要干什么（操作数据进行怎样的流通）？

下面图中的每个分点，就是一个个微操作，都需要一个时钟周期来运行。

1. 取指周期 FE (Fetch)

   取指令到IR

   ![指令周期 取指周期](<./img/指令周期 取指周期.jpg>)

2. 间址周期 IND (Indirect)

   间接寻址找有效地址EA

   ![指令周期 间址周期](<./img/指令周期 间址周期.jpg>)

3. 执行周期 EX (Execute)

   根据IR中的操作码，数据传送、ALU运算、或I\\O读写

   因操作码不同，所以数据流向不同，无法概括。

4. 中断周期 INT (Interrupt)

   堆栈指针SP++，存入PC的值（是+1个指令字长的值，这里就可以看到，这个操作是在取值周期中进行的的）

   ![指令周期 中断周期](<./img/指令周期 中断周期.jpg>)

除了第三个机器周期——执行周期，是会根据指令的操作码而发生变化的。

取指周期、间址周期、中断周期，对不同的操作码是通用的。

![机器周期 时钟周期 微操作](<./img/机器周期 时钟周期 微操作.jpg>)

这里的节拍T就是一个时钟周期。

而且可以发现，有些微操作是在不同机器周期间通用的。

### 指令的执行方案

一连串的指令该如何安排执行？

1. 单指令周期（笨）：串行，且所有指令安排相同的指令周期（时间短的也填充空闲期，与时间长的一致），效率低但硬件实现简单
2. 多指令周期（笨）：串行，指令周期就应该不同，效率高硬件实现更复杂
3. 流水线方案（好）：并行，让不同的指令处在指令周期内不同的阶段，尽可能全部利用CPU的各个部件

## 内部总线

数据通路的三种设计：（ALU的运算需要两个输入信号都稳定）

1. 单总线：所以得在ALU的一个输入端前放一个暂存寄存器，第一次传数据到暂存寄存器，第二次输入另一个ALU的输入端
2. 多总线：多条总线
3. 专用数据通路：各个部件之间都有专用的通路，就不用总线了（性能高、硬件复杂）

在数据的通路中（总线设计中是各个部件到总线的连线，专用数据通路中是各个部件之间的连线），有控制器把守的开关，当控制器发来了有效信号，才能进行数据传输。

## 控制器

为了让电路能够发生，也就是“从什么都不干到开始干”的过程，就得需要一个信号，比如接通导线，电流接通了，与非门运转了，逻辑就发生了。为了让电路一次又一次地接连发生，就得弄一个周而复始的信号流——时钟信号。时钟信号的上升沿就可以用来当发生器。

那么现在CU控制器拥有的信息：目前所处的机器周期、指令（n位操作码经过译码器对应$2^n$种指令）、时钟的节拍信号、机器状态条件（ALU的PSW、I/O设备或主存的状态）。CU需要用这些信息来决定发出哪些控制信号，以让数据在各个部件间流动，从而完成指令。

输入的是当前的状态，输出的是k种微操作：有k根线连到各种数据通路上的开关，从而发出k种控制信号（因为存在可并行的微操作，所以每次可能发出不只一个信号）

![控制器](<./img/控制器.jpg>)

有两种方法实现输入到输出：

- 硬布线：用一堆逻辑门即时产生
- 微程序：ROM查表

### 硬布线控制器

那我们可以整理出对于每一种微操作的控制信号，输入的是什么（$2^n$种指令、m个节拍、四个机器周期、好多个PSW标志位），就能汇总出一张巨大的真值表，这对硬件来说，就是一堆复杂的逻辑门。

那么在你头秃整理出所有的可能性后，列出了一张巨型表格，你就有了以下的结果：

![硬布线控制器 真值表](<./img/硬布线控制器 真值表.jpg>)

再弄成逻辑电路：

![硬布线控制器 逻辑门](<./img/硬布线控制器 逻辑门.jpg>)

这就是控制器内这一个状态对应的微操作的内部实现。

### 微程序控制器

另一种思路是把每一个时钟周期内的操作视为一个微指令（可能包含多个微操作（微命令），因为可能进行多部件的并行操作），把指令的执行视为一堆微指令的顺序执行，那么只需要有一个“从指令到微程序”的翻译器，就能做到从指令到控制信号的转换。

![微程序 微指令](<./img/微程序 微指令.jpg>)

微程序控制器的设计，这些微程序段存储在一个高速的ROM中。

![微程序控制器](<./img/微程序控制器.jpg>)

控制存储器 CM，用ROM实现，存储微指令

![微程序控制器 控制存储器](<./img/微程序控制器 控制存储器.jpg>)

微指令的格式

![微程序控制器 微指令](<./img/微程序控制器 微指令.jpg>)

在水平型微指令中，为了表示多种控制信号，有几种微指令操作码编码的方式：

![微程序控制器 微指令操作码编码](<./img/微程序控制器 微指令操作码编码.jpg>)

下地址的形成方式：

![微程序控制器 微指令下地址](<./img/微程序控制器 微指令下地址.jpg>)

微程序控制器在花费一个时钟周期执行完一个微指令后，还需要再花费一个时钟周期用于确定下一条微指令的地址，所以比硬布线控制器要慢很多

下图以取址周期的三个微指令为例

![微程序控制器 读取下地址](<./img/微程序控制器 读取下地址.jpg>)

### 对比

![微程序控制器 vs 硬布线控制器](<./img/微程序控制器 vs 硬布线控制器.jpg>)

## 指令流水线

最慢的执行方案是顺序执行，最快的是最大并行度（重叠度）的并行执行

![流水线](<./img/流水线.jpg>)

两种图示方法

![流水线 表示方法](<./img/流水线 表示方法.jpg>)

### 性能指标

取最理想的状态，即最大并行度，且一个机器周期仅需要一个时钟周期，且个机器周期耗时相同，且并行的操作不会产生额外的延时。

共n条指令，每个机器周期耗时$\Delta t$，完成一条指令需要k个机器周期。

则总时间为$(k+n-1)\Delta t$

![流水线 时空图](<./img/流水线 时空图.jpg>)

- 吞吐率：单位时间完成的指令数量：$\frac{n}{(k+n-1)\Delta t}$，则当n趋于无穷时，吞吐率为$\frac{1}{\Delta t}$

- 加速比：不使用流水线的时间与使用流水线的时间值比：$\frac{n*k}{k+n-1}$，则当n趋于无穷时，加速比为$k$

- 效率：设备工作的时空占总时空的比率

  即红色范围内的面积比整个矩形的面积（平移后就是底边长度之比）：$\frac{n}{k+n-1}$，则当n趋于无穷时，效率为$1$

### 影响流水线性能的因素

实际并不会那么理想，会有三种情况导致并行处理发生错误

为了深入讨论以及分析原因，这里介绍五分段的流水线

![流水线 五段结构](<./img/流水线 五段结构.jpg>)

依旧进行了一些理想化设定，如

- 存取都在Cache中可以命中
- 所有段的时间相同（取耗时最长的为标准）
- 每段后都有缓冲寄存器（锁存器），保存本段的执行结果
- 操作数已经在寄存器中（RISC架构，取操作数都是需要耗费一条LOAD指令先读到CPU通用寄存器中，再进行操作，存操作数也需要耗费一条STORE指令）

五段的工作分别为（各种指令对应的流水线，并不是五段都会发生，可能会空操作（什么都不做的一段时间））

1. IF (Instruction Fetch) 从Instruction Cache中取指令到段尾的锁存器（PC+="1"）

2. ID (Instruction Decode) 指令译码、从通用寄存器中取操作数或放立即数到段尾的锁存器

3. EX (Execute) 执行操作，结果放到段尾的锁存器

4. M (Memory) 只会在LOAD和STORE两条指令中生效，其它指令为空操作。

   LOAD时用EA在Cache中取数据并存到通用寄存器中。STORE时用EA和图中Store里的数据，存到Cache中。

   > 4.5 改变PC值的操作也在这一段同时发生，但因用时太少且与其他段相容，通常不标出

5. WB (Write Back) 写回通用寄存器

导致并行处理发生错误的三种情况：

1. **结构相关（资源冲突）**：同一时间有多个指令争用同一部件的资源

   > - 排在后的指令暂停一个机器周期
   > - 资源重复配置（如图中的Instruction Cache和Data Cache就是将两种数据分离存储在两块Cache上）

2. **数据相关（数据冲突）**：后续指令的输入依赖之前指令的输出，结果之前指令还没存，后续指令就去读了

   > - 把后续指令暂停几个机器周期，直到相关数据存好。可以用硬件阻塞或者软件编译器插入空指令实现暂停。
   > - 数据旁路技术\定向技术\相关专用通路技术：不需要等上一条指令存到寄存器后才开始后续指令，只要ALU输出结果了就能用了，所以在ALU的输出处接一些专用数据通路，比如到ALU的输入处
   > - 编译优化：编译器调整指令顺序（把后面不依赖于当前指令输出的指令往前移，节省等待时间）

3. **控制相关（控制冲突）**：条件转移、函数调用、函数返回的指令的后续指令无法预测，如果单纯执行了位于其后的，可能是在做无用功

   > 条件转移指令的优化方法
   >
   > - 简单预测分支：条件转移中，单纯执行为真或为假的后续指令，50%的概率有效嘛
   > - 动态预测分支：预测的准确率更高
   > - 指令预取：同时取来为真和为假的后续指令
   > - 加快计算条件
   >
   > ~~至于如何让执行到一半的无效指令停止，nge不晓得~~

### 流水线的分类

多功能流水线中的各段的连接方式

- 静态流水线：只能执行单种任务，切换操作需要等执行完了才能改
- 动态流水线：可执行多种功能

---

前面讲的都是控制器对指令的流水线，如果把这种思想扩展到CPU内的部件或者CPU与CPU之间？

流水线的等级

- 处理机级的流水（指令流水线）：控制器，把一条指令拆分为多个子过程，对多条指令进行流水
- 处理机间的流水：CPU，把一项任务拆分为多个子任务，对多个任务进行流水
- 部件功能级流水（运算流水线）：ALU，拆分为多种可并行的运算，对多次运算进行流水

### 流水线的多发技术

![流水线 多发技术](<./img/流水线 多发技术.jpg>)

- 超标量（空分复用）：同一个机器周期内同时运行多个相同的流水段

  > 需要配置多个的功能部件，由编译器决定哪些指令排在一起进行并行流水

- 超流水（时分复用）：把机器周期再细分

- 超长指令字：一条指令内塞入多个可以并行的操作码

  > 由编译器挖掘出可以并行的操作码，可能也需要配置多个功能部件

## 多处理器

S Single

M Multiple

I Instruction

D Data

补充一下并发（Concurrent）和并行（Parallel）的概念：

并发是交替观察者眼中的并行

![并发 并行](<./img/并发 并行.jpg>)

- **SISD** 单指令流单数据流：1个CPU+1个主存，这门课研究的就是这种

  **不能并行**

  

- **SIMD** 单指令流多数据流：CPU内有多个ALU，每次对多条数据进行相同的操作（比如数组元素全部+1）

  **数据级并行**

  - 向量处理机：操作的是向量

  

- ~~MISD 多指令流单数据流：多个指令同时处理一个数据，脑子进水了吧~~

  

- **MIMD** 多指令流多数据流：

  **数据级并行，线程级并行**

  - 多处理器系统：多核的CPU，各个核可以通过LOAD\STORE访问同一个主存，共享单一的物理地址（还共享同一个L1级（最外层）的Cache）
  - 多计算机系统：多台计算机，通过网络访问别人的主存

## 硬件多线程

![硬件多线程](<./img/硬件多线程.jpg>)

# 六、总线

总线是为多个部件进行分时传输数据的线路（共享同一线路，但得靠分时来并发）

早期计算机的外部设备较少，大多采用专用线路，不易进行增减设备。总线思想让所有的数据传输与控制放到一根（组）线上，使插拔变得灵活（但也使传输速率下降）

## 属性与分类

- 机械特性：尺寸、形状、针脚个数、排列顺序

- 电气特性：传输方向（单向传输\\双向传输）、有效电平范围（什么范围的电压是高电平\\低电平）

- 时间特性：什么时候是有效的

- 数据传输格式：

  - 串行总线：一根线，一次只传输1bit，成本低廉，不易受到干扰，适合长距离传输。

    比如USB。

  - 并行总线：多根线，一次传输多个bit。成本高，易受到干扰，不适合长距离传输。

    比如主板上的总线。

  - <u>并行总线不一定比串行总线速度快，因为串行总线的频率可以比并行的更高，并行多根线内信号传递到达终点的时间有差别，提高频率就会增大差距，从而错乱；而且串行也可以像网络一样扩展为多线分包再拼装</u>

  - <u>由于系统总线是并行的（存取处理数据还是一次读完多个字节比较好），串行总线与系统总线的交接还需要一个串行\\并行转换的部件</u>

- 工作范围：

  - 片内总线：CPU内部，寄存器、ALU之间

  - 系统总线：计算机内部，CPU、主存、I/O接口之间

    最开始都是并行总线的，2000年之后逐渐都变成串行的了。

    地址\\数据\\控制总线

    ![总线 系统总线](<./img/总线 系统总线.jpg>)
  
  - I/O总线：低中速设备与系统总线之间，如USB
  
  - 通信总线：计算机之间，如网线

## 系统总线的结构

见[I/O系统](#八、输入输出系统)

## 性能指标

- 总线周期（总线传输周期）：一次传输需要的时间，可能大于时钟周期，也可能小于时钟周期（上升沿和下降沿激发了两次传输）

  总线工作频率：1/总线周期

- 总线时钟周期：可能由CPU决定，也可能由桥接器决定

  总线时钟频率：1/总线时钟周期

- 总线宽度：数据总线的根数

- 总线带宽：单位时间数据总线上传输的位数=总线工作频率*总线宽度

  是最高传输速率，与有效传输速率不同

- 信号线数：所有线的根数的和

## 其他技术

突发（猝发）传输：寻址的是一个连续数据单元的首地址，可以一直连续传输该地址后的多个字的数据且总线不用释放，直到传输完毕。

总线复用：地址线和数据线共用一组总线，得时分复用。

## 总线通信控制

### 同步通信

由统一时钟控制，比如由CPU控制

控制逻辑简单，传输速度快。

但为了使所有设备能同步，就得按最慢的设备的周期来设定时钟，这就严重影响工作效率。时间卡得紧，如果从设备跟不上主设备（比如CPU）的节奏，不能及时地提供数据，也缺少时间进行有效性检验，所以可靠性差。

所以同步通信适用于总线长度较短，各部件存取时间相差小的情况。

### 异步通信

采用应答方式，总线周期可变，通信的双方自动适配时间

所以异步通信适用于各部件存取时间相差大的情况

但控制方式更复杂，传输速度更慢

![总线 异步通信](<./img/总线 异步通信.jpg>)

## 总线周期

![总线 总线周期](<./img/总线 总线周期.jpg>)

## 总线仲裁

不考待看

决定哪个设备获得总线的使用权

# 七、中断

这里指广义的中断，因为CPU的内中断（异常）和外中断（狭义的中断）的处理方式差不多。这两者的渊源与差异见《操作系统》的“异常与中断”。

如果没有中断，在跑一个程序时，就不能对鼠标的移动进行响应

## 单重中断

![中断 单重中断](<./img/中断 单重中断.jpg>)

1. 中断请求：中断源向CPU发送中断请求信号

   > INTR (Interrupt Request) 中断请求标记
   >
   > 中断请求标记可能存在CPU内的中断请求寄存器，也可能分布在各个中断源的寄存器中。
   >
   > CPU控制器在每个指令周期的末尾会检查这些位是否有1。图中左边的优先级高，右边的优先级低。
   >
   > ![中断 INTR](<./img/中断 INTR.jpg>)

2. 中断响应：若有中断请求，且PSW中的IF（Interrupt Flag，IF=1为开中断，表示允许中断）处于开中断状态，则允许中断。因为一次只能处理一个中断，所以需要进行[中断判优](#中断判优)，选出最优先的中断源。

3. 中断处理

   1. 中断隐指令（CPU在中断周期中由硬件自动完成的一些操作）：
      1. 关中断
      2. 保护程序断点：PC+"1"的值进栈
      3. 保护程序状态字PSW，并将记录CPU模式的PSW改为内核态
      4. [引出中断服务程序](#引出中断服务程序)（中断服务程序的首地址）
   2. 中断服务程序
      1. 保护现场：存ACC、寄存器等
      2. 中断服务
      3. 恢复现场
      4. 开中断
      5. 返回

## 中断判优

可用硬件实现，硬件排队器，速度快。

也可用软件实现，查询程序，一位位查，速度慢。

![中断 中断判优](<./img/中断 中断判优.jpg>)

一些常规的优先级

![中断 优先级](<./img/中断 优先级.jpg>)

## 引出中断服务程序

![中断 向量地址](<./img/中断 向量地址.jpg>)

中断向量 = [向量地址]

为什么非得搞个间接寻址呢？

因为中断服务程序是操作系统和驱动程序提供的，是可变的。

这些内存中的中断向量，是在开机时动态生成的。

而向量地址可以由CPU和ROM写死。

## 多重中断

![中断 多重中断](<./img/中断 多重中断.jpg>)

深层的中断应该优先级高于本层。不能自己套自己（比如键盘中断时，又来了一个键盘中断），也不能在高优先级中断中处理低优先级。

带有屏蔽字的判优（图中的屏蔽字表示不允许任何深层）：不允许深层中断的设为1（自己的地方肯定为1）

![中断 多重中断 屏蔽字判优](<./img/中断 多重中断 屏蔽字判优.jpg>)

每一种中断都有自己的屏蔽字

![中断 多重中断 屏蔽字](<./img/中断 多重中断 屏蔽字.jpg>)

所以多重中断的流程如下：

在单重中断保护好现场后，保存当前中断的屏蔽字（深层中断回归后再次发生中断，就还会需要当前中断的屏蔽字），设IF为1开中断，就在这个机器周期里：

- 若有新来的中断，且用附加了屏蔽字的逻辑判优有效，则执行深一层的中断服务程序。
- 若无，则关中断，继续执行本中断的服务程序。

# 八、输入输出系统

I/O硬件包括I/O设备、I/O接口

I/O设备包括输入设备（键盘、鼠标、传感器等）、输出设备（屏幕、音响、打印机等）、外存（光盘、磁盘、硬盘等）

![IO系统](<./img/IO系统.jpg>)

按使用特性分类

- 人机交互类外部设备
- 存储设备
- 网络通信设备

按传输速率分类：

- 低速
- 中速
- 高速

按信息交换的单位分类：

- 块设备，可寻址
- 字符设备，不可寻址，用中断方式

---

I/O接口，又称I/O控制器、设备控制器，是一种芯片，在现代主板就集成到南桥芯片中了。

I/O控制器就像分封制的诸侯，CPU这个皇帝要控制I/O控制器，并与之通信。

![单总线](<./img/单总线.jpg>)

CPU让I/O控制器去从I/O设备中读数据后，会有一定时间的等待，CPU如何从等待并从I/O控制器中取回数据呢？

- 程序查询方式：CPU轮询。在I/O设备与I/O控制器交换数据的过程中，CPU得一直去检查I/O控制器的状态寄存器是否表明“已完成”。这近乎访存，在这期间CPU不能去干其他事。
- 程序中断方式：由I/O控制器上报中断请求。CPU的每个时钟周期只需要查看是否有中断信号就行。一旦中断，就运行取回数据的中断服务程序。

相比于键盘的输入，磁盘、硬盘这种高速设备的输入数据量会大很多，连续去执行中断服务程序就很低效，于是设计了DMA (Direct Memory Access)的设计，DMA也是一种I/O接口，但可以与主存直接连接。

CPU告诉DMA要读入主存，指明主存地址、磁盘地址、数据量（比如1KB），然后CPU就可以做其他事情去了。接着DMA一个字一个字读，直到完成了，再发中断请求给CPU。

![IO DMA 三总线](<./img/IO DMA 三总线.jpg>)

如果有很多高速设备，而且需要复杂的存取任务？CPU再把这些活外包给“通道”，通道可以读取主存中存储的通道程序，按照一系列程序存取（与CPU并行），执行完通道程序再发中断请求给CPU。

一个通道可以控制多个I/O控制器，一个I/O接口可以控制多个I/O设备。

![IO 通道 双总线](<./img/IO 通道 双总线.jpg>)

![IO 通道](<./img/IO 通道.jpg>)

现代主板里用北桥南桥分别管理高速低速的I/O设备。

> - 单总线结构
>
>   > 结构简单，成本低
>   >
>   > 带宽低
>
> - 双总线结构：将低速的I/O设备隔离，用通道（桥接器，一种类似CPU的管理器）与更靠内的总线连接
>
> - 三总线结构：将更高速的I/O用DMA总线与主存相连
>
>   > 相应更快，吞吐量更大
>   >
>   > 但主存总线和DMA总线不能同时工作（不能两个同时访问主存），工作效率比较低

## I/O接口

这章讲得太差了，没有技术细节，全是删减后的“重点”，走马观花我他妈吐一路🤮

实现主机与外设的通信

- 数据缓冲：通过数据寄存器缓冲数据
- 地址译码和设备选择
- 错误或状态监控：通过状态寄存器反馈外设的错误、状态
- 控制和定时：接受控制总线来的控制信号、时钟信号
- 数据格式转换：串行（外部）\\并行（内部）转换

CPU控制器看到的指令：`I/O指令的操作码（给CPU用的） I/O设备命令码（给I/O接口用的） 设备码（端口地址）`

❓凑合看吧，傻逼教材也没说存取外设数据的地址是怎么传输的，国外也找不到。（好像是在命令字中的）

![IO 接口](<./img/IO 接口.jpg>)

I/O端口（寄存器）编址（❓也没说访存具体是如何实现的……

大概讲的是寄存器地址的编码方式，具体寻址的时候是把地址传到I/O接口的地址线的端口。

![IO 端口编址](<./img\IO 端口编址.jpg>)

- 统一编制\\存储器映射方式：靠不同的地址码分区区分主存地址与I/O端口地址

  > 优点：
  >
  > - 不需要专门的输入输入指令
  > - 端口有较大的编制空间
  > - 读写控制电路简单
  >
  > 缺点：
  >
  > - I/O端口占用了有限的主存地址空间
  > - 地址位数多，译码慢

- 独立编址：靠不同的指令区分主存地址与I/O端口地址

  > 优点：
  >
  > - 地址位数可以很少，译码快
  > - I/O端口不占用了主存地址空间
  >
  > 缺点：
  >
  > - 需要专用的I/O读写指令
  > - I/O读写指令类型少，程序设计灵活性差
  > - 读写控制电路复杂

## I/O控制方式

![IO 控制方式](<./img/IO 控制方式.jpg>)

### 程序查询方式

![IO 程序查询方式](<./img/IO 程序查询方式.jpg>)

### 程序中断方式

每个字都要中断一下，让CPU来取数据

![IO 程序中断方式](<./img/IO 程序中断方式.jpg>)

### DMA方式

![IO DMA](<./img/IO DMA.jpg>)

数据缓冲存储器可以存一个数据块

所有的都传输好了，才中断，告诉CPU我干完了

- 单总线

  DMA读入每个块后，向CPU申请系统总线的控制权，传输一下。

  得在数据缓冲存储器满了时，DMA请求触发器发送DMA请求，向CPU申请总线的控制权，传输一个块的内容到主存。

- 三总线

  有DMA（专用）总线，不用申请系统总线的控制权。
  
  但与CPU会争用主存，有三种DMA传送方式
  
  ![IO DMA传送方式](<./img/IO DMA传送方式.jpg>)

流程如下：

1. I/O指令，CPU预处理：
   1. 测试I/O设备状态
   2. 向DMA中的寄存器置初值，主存的起始地址->AR，I/O设备地址->DAR，传送数据块的个数->WC
   3. 启动I/O设备
2. DMA工作：
   - 单总线，CPU批准总线的控制权
   - 三总线，偶尔和CPU争用访存
3. DMA工作完，中断请求。CPU中断服务程序，包括校验、测试或者让DMA继续存取。之后CPU继续执行本来的主程序
