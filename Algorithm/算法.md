待 cs170

# 贪心

找出能得到最优选择的规律

# 递归

recursion

求解大规模的问题转化为求解小规模的问题

是深度优先（DFS）的搜索

状态转移方程：

$f(n)=f(n-1)+f(n-2), f(1)=1, f(2)=1$​

```python
def fib(n):
    if n <= 2: # base case
        return 1
    return fib(n-1) + fib(n-2)
```

搜索空间太大，会栈爆、超时，几种解决方法：

1. 如果有合法性的限制，那就要在做出选择的时候分为合法和非法两种情况讨论
2. 将子问题的解记忆下来，作为可以直接用的base case
3. 用[动态规划](#动态规划)：从小问题开始着手，大问题由小问题推导而来

## 卡特兰数

Catalan

$Catalan = 1,1,2,5,14,42,132$

许多组合数学问题都可以`归约`❓到一种问题：“对排成一行的n个东西在任意位置递归地划分左右组，总共有多少种划分法”

$ H_n=\sum_{i=0}^{n-1}H_{i}H_{n-i-1}\ (n\ge 2),\ H_0=1,\ H_1=1\\$

1. 一种进栈序列，对应几种出栈序列？
2. 一个包含n个节点的二叉树，有几种树的形态？
3. n对匹配的括号，有几种字符串的可能？
4. 在方格走路，从左上角走到右下角，只能向下或向右走，且不能越过对角线，有几种走法？

也有直接公式：$ H_n = \frac{\C^{n}_{2n}}{n+1}(n \ge 2)\\$

# 动态规划

Dynamic Programming

自顶向下分析，从底向上计算。

让大问题（巨量的搜索空间）可由前置的子问题（最优子结构）推导得解

数塔问题、最长子序列问题

### 背包问题

[背包 DP - OI Wiki](https://oi-wiki.org/dp/knapsack/)

一堆物品，重量`w[n]`、价值`v[n]`，放入容量限制为`W`的背包，获得的最大价值为多少？

最优子结构：只选前几个物品时、背包容量为各种值时的最优解

- 01背包：每种物品只有一个，要么选要么不选

  ```java
  int[] dp = new int[W+1]{}; // 容量为0到W时的最优解，初值为0
  int[] w = new int[n];
  int[] v = new int[n];
  // 遍历所有物品，后面遍历的依赖于前面的（只选前几个物品时）
  for (int i = 0; i < n; i++){
      // 从多到少，背包容量为各种值时的最优解
      for (int l = W; l >= w[i]; l--) {
          dp[l] = max(dp[l], dp[l - w[i]] + v[i]);     
      }
  }
  return dp[W];
  ```

- 完全背包：每种物品无数个，可以选任意个

  > 可以把每种物品复制为`W//w[i]`份，转化为01背包，但这样容易超时

  ```java
  int[] dp = new int[W+1]{};
  int[] w = new int[n];
  int[] v = new int[n];
  for (int i = 0; i < n; i++){
      // 改为从少到多，这样才能让一个物品考虑多次
      for (int l = w[i]; l <= W; l++) {
          dp[l] = max(dp[l], dp[l - w[i]] + v[i]);     
      }
  }
  return dp[W];
  ```

- 多重背包：每种物品有限定的个数

  > 可以把每种物品复制为多份，转化为01背包，但这样容易超时

  考虑用二进制分组的思想，把每种物品组合为2的阶数

  如100个物品，分为1+2+4+8+16+32+37的几组，用这些组可以构成1-100内的任意个数

  ```java
  int t = 1;
  while (x >= t) {
      l.add(t);
      x -= t;
      t *= 2;
  }
  if (x > 0) {
      l.add(x);
  }
  ```

# 搜索

求从起始状态到目标状态最少需要几次转移（状态图中的最短路径），状态图的边是根据当前状态和转移规则向周边动态生成的。

用visited数组存储已经探索过的，避免重复搜索（所以就不是状态图了，而是状态树）

# P/NP

P：判断出是否为真

NP：求解

压缩、有向图的最长路径、都属于NP问题？NP问题可以互相转化？

压缩==智能

如果P=NP，那么数学证明将可以自动生成